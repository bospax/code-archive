# RTK Query

### Setup & Core Usage

```jsx
import { createApi, fetchBaseQuery } from '@reduxjs/toolkit/query/react';

// createApi: Creates an API slice.
// reducerPath: A unique identifier for the slice in the Redux store.
// baseQuery: Defines the base URL for all requests within this slice.
// endpoints: Defines each endpoint with the methods (query, mutation) provided by RTK Query.
// query: Defines a GET request endpoint.

const booksApi = createApi({
	reducerPath: 'booksApi', // Unique name for this API slice
	baseQuery: fetchBaseQuery({ baseUrl: '/api' }), // Base URL for your API
	endpoints: (builder) => ({
		getBooks: builder.query({
			query: () => 'books', // Relative URL of the endpoint
		}),
	}),
});

// useGetBooksQuery hook is auto-generated by RTK Query
export const { useGetBooksQuery } = booksApi;
export default booksApi;

// Integrate with Redux Store
import { configureStore } from '@reduxjs/toolkit';
import { setupListeners } from '@reduxjs/toolkit/query';
import booksApi from './booksApi';

// booksApi.reducer: Adds the reducer for managing API-related state.
// booksApi.middleware: Ensures that caching, invalidation, and polling work as expected.
// setupListeners: Adds listeners to re-fetch data on focus or reconnect events

const store = configureStore({
	reducer: {
		[booksApi.reducerPath]: booksApi.reducer,
	},
	middleware: (getDefaultMiddleware) =>
		getDefaultMiddleware().concat(booksApi.middleware),
});

setupListeners(store.dispatch);
export default store;

// store with api reducer and sync reducer
import { configureStore } from '@reduxjs/toolkit';
import { productsApi } from '../features/products/productsApi';
import { authApi } from '../features/auth/authApi';
import cartReducer from '../features/cart/cartSlice';
import authReducer from '../features/auth/authSlice';

export const store = configureStore({
	reducer: {
		[productsApi.reducerPath]: productsApi.reducer,
		[authApi.reducerPath]: authApi.reducer,
		cart: cartReducer,
		auth: authReducer,
	},
	middleware: (getDefaultMiddleware) =>
		getDefaultMiddleware().concat(productsApi.middleware, authApi.middleware),
});
```

```jsx
// Using the Query in a Component
import React from 'react';
import { useGetBooksQuery } from './booksApi';

// useGetBooksQuery: Automatically triggers the request and provides data, isLoading, and error.
// isLoading, error: Help manage UI feedback based on request status

const BooksList = () => {
	const { data: books, error, isLoading } = useGetBooksQuery();

	if (isLoading) return <p>Loading...</p>;
	if (error) return <p>Error: {error.message}</p>;

	return (
		<ul>
			{books.map((book) => (
				<li key={book.id}>{book.title}</li>
			))}
		</ul>
	);
};

export default BooksList;
```

```jsx
// Intermediate Usage: Mutations for CRUD Operations
// Mutations in RTK Query handle non-GET requests, like POST, PUT, DELETE
endpoints: (builder) => ({
	getBooks: builder.query({
		query: () => 'books',
	}),
	addBook: builder.mutation({
		query: (newBook) => ({
			url: 'books',
			method: 'POST',
			body: newBook,
		}),
	}),
}),

import React, { useState } from 'react';
import { useAddBookMutation } from './booksApi';

// useAddBookMutation: Returns a function that can trigger the addBook mutation.
// unwrap: Returns a promise that you can handle with .then() or await, simplifying error handling

const AddBookForm = () => {
	const [addBook] = useAddBookMutation();
	const [title, setTitle] = useState('');

	const handleAddBook = async () => {
		try {
			// Without .unwrap(): addBook() returns a promise that always resolves, whether it’s successful or not.
			// You can only access isSuccess or isError to determine the state.
			// With .unwrap(): You get a resolved value if the mutation is successful and a rejected error if it fails,
			// allowing you to handle the error directly in a try-catch block
			await addBook({ title }).unwrap();
		} catch (error) {
			console.error('Failed to add book:', error);
		}
	};

	return (
		<div>
			<input value={title} onChange={(e) => setTitle(e.target.value)} />
			<button onClick={handleAddBook}>Add Book</button>
		</div>
	);
};

// Handling a Mutation with and without .unwrap()
const [addBook] = useAddBookMutation();

const handleAddBook = async () => {
	const result = await addBook({ title: 'New Book' });

	if (result.error) {
		console.error('Failed to add book:', result.error);
	} else {
		console.log('Book added successfully:', result.data);
	}
};

// Advanced Features: Caching and Invalidating
// providesTags: Marks data fetched by getBooks as Books.
// invalidatesTags: Tells RTK Query to refetch getBooks after addBook runs
endpoints: (builder) => ({
	getBooks: builder.query({
		query: () => 'books',
		providesTags: ['Books'],
	}),
	addBook: builder.mutation({
		query: (newBook) => ({
			url: 'books',
			method: 'POST',
			body: newBook,
		}),
		invalidatesTags: ['Books'],
	}),
}),
```

```jsx
// caching and invalidating with single data
// src/features/products/productsApi.js
import { createApi, fetchBaseQuery } from '@reduxjs/toolkit/query/react';

export const productsApi = createApi({
	reducerPath: 'productsApi',
	baseQuery: fetchBaseQuery({ baseUrl: '/api' }),
	tagTypes: ['Product'], // Define tag type here
	endpoints: (builder) => ({
		getProductById: builder.query({
			query: (id) => `products/${id}`,
			// providesTags - when getProductById is called, it generates a tag based on the id provided and associates the returned data with this tag
			// result: Contains the data returned from the query or mutation if successful.
			// error: Contains any error if the query or mutation fails.
			// id or { id }: Represents the unique identifier passed into the function when calling the query or mutation.
			providesTags: (result, error, id) => [{ type: 'Product', id }],
		}),
		updateProduct: builder.mutation({
			query: ({ id, ...patch }) => ({
				url: `products/${id}`,
				method: 'PATCH',
				body: patch,
			}),
			// invalidatesTags to invalidate the cache of a product by its id. When updateProduct is called, it triggers a cache invalidation for the specified id, which then prompts RTK Query to refetch the product’s data wherever it’s used in the app
			invalidatesTags: (result, error, { id }) => [
				{ type: 'Product', id },
			],
		}),
	}),
});

export const { useGetProductByIdQuery, useUpdateProductMutation } = productsApi;

// src/features/products/ProductEdit.js
import React, { useState } from 'react';
import {
	useGetProductByIdQuery,
	useUpdateProductMutation,
} from './productsApi';

const ProductEdit = ({ productId }) => {
	const { data: product, isLoading } = useGetProductByIdQuery(productId);
	const [updateProduct] = useUpdateProductMutation();

	const [name, setName] = useState(product?.name || '');
	const [price, setPrice] = useState(product?.price || '');

	if (isLoading) return <p>Loading product...</p>;

	const handleSave = async () => {
		try {
			// Call the update mutation with new data
			await updateProduct({ id: productId, name, price });
			alert('Product updated successfully');
		} catch {
			alert('Failed to update product');
		}
	};

	return (
		<div>
			<h2>Edit Product</h2>
			<input
				type="text"
				value={name}
				onChange={(e) => setName(e.target.value)}
			/>
			<input
				type="number"
				value={price}
				onChange={(e) => setPrice(e.target.value)}
			/>
			<button onClick={handleSave}>Save Changes</button>
		</div>
	);
};
```

```jsx
// Multiple tagTypes: Products and Categories
// Initial Fetch:
// When getProductById or getCategoryById is called, RTK Query fetches the data and tags it with { type: 'Product', id } or { type: 'Category', id } respectively, caching it for future access.

// Updating Data:
// When updateProduct or updateCategory is called, RTK Query invalidates the relevant tag (based on the id), marking it as outdated.

// Refetching Cached Data:
// The next time a query for getProductById with the invalidated id is called, RTK Query refetches only that product, ensuring the app displays the latest data without redundant requests.
const api = createApi({
	reducerPath: 'api',
	baseQuery: fetchBaseQuery({ baseUrl: '/api' }),
	// If you attempt to use a type that is not listed in the tagTypes array,
	// like [{ type: 'Category', id }] when 'Category' isn’t included in tagTypes, RTK Query will throw an error
	tagTypes: ['Product', 'Category'],
	endpoints: (builder) => ({
		// Endpoint to fetch a product by ID, providing a Product tag
		getProductById: builder.query({
			query: (id) => `products/${id}`,
			providesTags: (result, error, id) => [{ type: 'Product', id }],
		}),
		// Endpoint to update a product, invalidating the Product tag for the specified ID
		updateProduct: builder.mutation({
			query: ({ id, ...patch }) => ({
				url: `products/${id}`,
				method: 'PATCH',
				body: patch,
			}),
			// invalidatesTags: [{ type: 'Product', id }] marks the data tagged with { type: 'Product', id } as outdated, specifically for the given id
			// This means any cached data associated with this product ID will be refetched
			invalidatesTags: (result, error, { id }) => [
				{ type: 'Product', id },
			],
		}),
		// Endpoint to fetch a category by ID, providing a Category tag
		getCategoryById: builder.query({
			query: (id) => `categories/${id}`,
			providesTags: (result, error, id) => [{ type: 'Category', id }],
		}),
		// Endpoint to update a category, invalidating the Category tag for the specified ID
		updateCategory: builder.mutation({
			query: ({ id, ...patch }) => ({
				url: `categories/${id}`,
				method: 'PATCH',
				body: patch,
			}),
			invalidatesTags: (result, error, { id }) => [
				{ type: 'Category', id },
			],
		}),
	}),
});
```

```jsx
// utilizing the result parameter in tags
// result parameter in providesTags and invalidatesTags carries the result of the query or mutation—essentially,
// the data fetched from or sent to the server
providesTags: (result, error, id) => [{ type: 'Category', id }];

// Here, result contains the fetched data from the getProductById endpoint.
// You can use result to tailor how caching should happen based on what data is returned
providesTags: (result, error, id) =>
	result
		? [
				{ type: 'Category', id },
				...result.relatedProducts.map((related) => ({
					type: 'Category',
					id: related.id,
				})),
		  ]
		: [];

// Updating Cache Directly
// Using the updateQueryData method, you can directly set the new data in the cache without an additional server request
// This approach prevents the need for refetching by directly modifying the cached data for getProductById based on the mutation’s result
import { productsApi } from '../features/products/productsApi';

const [updateProduct] = useUpdateProductMutation();
const { updateQueryData } = productsApi.util;

// updateQueryData function is part of RTK Query’s API utilities and is accessible through productsApi.util in the slice setup
const handleSave = async () => {
	try {
		const updatedData = await updateProduct({
			id: productId,
			name,
			price,
		}).unwrap();
		// Update the cache directly
		updateQueryData('getProductById', productId, (draft) => {
			// update the properties / data inside draft with the updated data
			Object.assign(draft, updatedData);
		});
	} catch {
		alert('Failed to update product');
	}
};
```

### Toolkit, Thunk & RTK Query

```jsx
// src/app/rootReducer.js
import { combineReducers } from '@reduxjs/toolkit';
import authReducer from '../features/auth/authSlice';
import cartReducer from '../features/cart/cartSlice';
import productsReducer from '../features/products/productsSlice';
import { productsApi } from '../src/services/productService';
import { cartApi } from '../src/services/cartService';
import { authApi } from '../src/services/authService';

const rootReducer = combineReducers({
	auth: authReducer,
	cart: cartReducer,
	products: productsReducer,
	[productsApi.reducerPath]: productsApi.reducer,
	[cartApi.reducerPath]: cartApi.reducer,
	[authApi.reducerPath]: authApi.reducer,
});

export default rootReducer;

// src/app/store.js
import { configureStore } from '@reduxjs/toolkit';
import rootReducer from './rootReducer';
import { productsApi } from '../features/products/productsSlice';
import { cartApi } from '../features/cart/cartSlice';
import { authApi } from '../features/auth/authSlice';

const store = configureStore({
	reducer: rootReducer,
	middleware: (getDefaultMiddleware) =>
		getDefaultMiddleware().concat(
			productsApi.middleware,
			cartApi.middleware,
			authApi.middleware
		),
});

export default store;

// src/index.js
import { Provider } from 'react-redux';
import store from './app/store';

ReactDOM.render(
	<Provider store={store}>
		<App />
	</Provider>
);

// cartService.js
import { createApi, fetchBaseQuery } from '@reduxjs/toolkit/query/react';

export const cartApi = createApi({
	reducerPath: 'cartApi',
	baseQuery: fetchBaseQuery({ baseUrl: 'https://fakestoreapi.com' }),
	endpoints: (builder) => ({
		getCart: builder.query({
			query: (id) => `/cart/${id}`,
		}),
		addItemToCart: builder.mutation({
			query: (item) => ({
				url: `/cart`,
				method: 'POST',
				body: item,
			}),
		}),
		removeItemFromCart: builder.mutation({
			query: (id) => ({
				url: `/cart/${id}`,
				method: 'DELETE',
			}),
		}),
	}),
});

export const { useGetCartQuery, useAddItemToCartMutation, useRemoveItemFromCartMutation } = cartApi;
```

```jsx
// cartActions.js
// Thunks can handle more complex workflows, such as chaining multiple API calls or processing data after a request
// Thunks can be dispatched conditionally, manually triggered as needed
// RTK Query, by design, focuses on simple fetches or mutations and may not handle multi-step processes as cleanly
import { cartApi } from '../services/cartService';
import { createAsyncThunk } from '@reduxjs/toolkit';

// Action to refetch cart data by forcing a refetch
export const refetchCart = createAsyncThunk(
	'cart/refetchCart',
	async (id, { dispatch }) => {
		// dispatches the cartApi mutation internally
		// Calls the login endpoint in cartApi initiate triggers the API call and returns the response
		// { forceRefetch: true } argument forces RTK Query to bypass caching and fetch fresh data directly from the server
		await dispatch(
			cartApi.endpoints.getCart.initiate(id, { forceRefetch: true })
		);
	}
);

// Action to add an item to the cart
export const addItemToCart = createAsyncThunk(
	'cart/addItemToCart',
	async (item, { dispatch, rejectWithValue }) => {
		const result = await dispatch(
			cartApi.endpoints.addItemToCart.initiate(item)
		);

		// Optionally handle success or error logic here
		if (result.error) {
			console.error('Failed to add item to cart:', result.error);
			return rejectWithValue(result.error);
		} else {
			console.log('Item added to cart successfully:', result.data);

			// call refetchCart to get an updated cart state that reflects the new added item
			dispatch(refetchCart(result.data.id));

			// Return the result for any further handling
			return result.data;
		}
	}
);

export const removeItemFromCart = createAsyncThunk(
	'cart/removeItemFromCart',
	async (id, { dispatch, rejectWithValue }) => {
		const result = await dispatch(
			cartApi.endpoints.removeItemFromCart.initiate(id)
		);

		if (result.error) {
			console.error('Failed to remove item from cart:', result.error);
			return rejectWithValue(result.error);
		} else {
			console.log('Item removed from cart successfully');
			dispatch(refetchCart(id));
			return id;
		}
	}
);

// cartSlice.js
import { createSlice } from '@reduxjs/toolkit';
import { cartApi } from '../services/cartService';

// Define initial state for cart
const initialState = {
	items: [], // To hold cart items locally
	loading: false,
	error: null,
};
```

```jsx
// Define the cart slice
const cartSlice = createSlice({
	name: 'cart',
	initialState,
	reducers: {},
	extraReducers: (builder) => {
		// Handle RTK Query endpoints
		// .addMatcher is a method that lets you set up specific conditions for listening to actions generated by RTK Query
		// cartApi.endpoints.getCart.matchFulfilled - This matcher triggers when the getCart query is successfully fulfilled
		// meaning data is returned successfully from the API.
		builder
			.addMatcher(
				cartApi.endpoints.getCart.matchFulfilled,
				(state, action) => {
					state.items = action.payload; // Set items to the cart data fetched
				}
			)
			.addMatcher(
				cartApi.endpoints.addItemToCart.matchPending,
				(state) => {
					state.loading = true;
					state.error = null;
				}
			)
			.addMatcher(
				cartApi.endpoints.addItemToCart.matchFulfilled,
				(state, action) => {
					state.items.push(action.payload); // Add the new item to the cart
					state.loading = false;
				}
			)
			.addMatcher(
				cartApi.endpoints.addItemToCart.matchRejected,
				(state, action) => {
					state.error = action.error.message;
					state.loading = false;
				}
			)
			.addMatcher(
				cartApi.endpoints.removeItemFromCart.matchPending,
				(state) => {
					state.loading = true;
					state.error = null;
				}
			)
			// handle the case when the removeItemFromCart mutation has completed successfully
			.addMatcher(
				cartApi.endpoints.removeItemFromCart.matchFulfilled,
				(state, action) => {
					// action.meta.arg.originalArgs is a way to access the original arguments passed to the mutation when it was first called
					// action: Refers to the action object created when removeItemFromCart mutation is dispatched and completed.
					// meta: Holds metadata about the action, including the arguments initially passed to the mutation.
					// arg: Contains data about the arguments of the mutation request.
					// originalArgs: Refers to the exact value (in this case, the item ID) sent to the mutation request.
					// dispatch(removeItemFromCart(3));
					state.items = state.items.filter(
						(item) => item.id !== action.meta.arg.originalArgs
					);
					state.loading = false;
				}
			)
			.addMatcher(
				cartApi.endpoints.removeItemFromCart.matchRejected,
				(state, action) => {
					state.error = action.error.message;
					state.loading = false;
				}
			);
	},
});

export default cartSlice.reducer;
```

```jsx
// authService.js
import { createApi, fetchBaseQuery } from '@reduxjs/toolkit/query/react';

export const authApi = createApi({
	reducerPath: 'authApi',
	baseQuery: fetchBaseQuery({ baseUrl: 'https://fakestoreapi.com/' }),
	endpoints: (builder) => ({
		login: builder.mutation({
			query: (credentials) => ({
				url: 'auth/login',
				method: 'POST',
				body: credentials,
			}),
		}),
		getProfile: builder.query({
			query: () => 'auth/user',
		}),
	}),
});

export const { useLoginMutation, useGetProfileQuery } = authApi;

// src/features/auth/authActions.js
import { createAsyncThunk } from '@reduxjs/toolkit';
import { authApi } from '../../services/authService';

export const login = createAsyncThunk('auth/login', async (credentials) => {
	await authApi.endpoints.login.initiate(credentials);
});

// using dispatch to extract the data property from the response of ThunkAction
export const login = createAsyncThunk(
	'auth/login',
	async (credentials, { dispatch }) => {
		const response = await dispatch(
			authApi.endpoints.login.initiate(credentials)
		);

		// return only the serializable data payload not the whole response object
		return response.data;
	}
);

// using unwrap together with dispatch to get data without non-serializable values
export const login = createAsyncThunk(
	'auth/login',
	async (credentials, { dispatch }) => {
		// // Call the API endpoint and wait for the result, then unwrap to get the data
		const response = await dispatch(
			authApi.endpoints.login.initiate(credentials)
		).unwrap();

		// this now returns a serializable values
		return response;
	}
);

// src/features/auth/authSlice.js
import { createSlice, createAsyncThunk } from '@reduxjs/toolkit';
import { authApi } from '../../services/authService';

const authSlice = createSlice({
	name: 'auth',
	initialState: { user: null, status: 'idle', error: null },
	reducers: {
		logout(state) {
			state.user = null;
		},
	},
	extraReducers: (builder) => {
		builder
			.addMatcher(
				authApi.endpoints.login.matchFulfilled,
				(state, action) => {
					state.user = action.payload;
				}
			)
			.addMatcher(
				authApi.endpoints.getProfile.matchFulfilled,
				(state, action) => {
					state.user = action.payload;
				}
			);
	},
});

export const { logout } = authSlice.actions;
export default authSlice.reducer;
```

```jsx
// productService.js
import { createApi, fetchBaseQuery } from '@reduxjs/toolkit/query/react';

export const productsApi = createApi({
	reducerPath: 'productsApi',
	baseQuery: fetchBaseQuery({ baseUrl: 'https://fakestoreapi.com/' }),
	endpoints: (builder) => ({
		getProducts: builder.query({
			query: () => 'products',
		}),
	}),
});

export const { useGetProductsQuery } = productsApi;

// src/features/products/productsActions.js
import { createAsyncThunk } from '@reduxjs/toolkit';
import { productsApi } from '../../services/api';

export const fetchProducts = createAsyncThunk(
	'products/fetchProducts',
	async () => {
		const response = await productsApi.endpoints.getProducts.initiate();
		return response.data;
	}
);

// src/features/products/productsSlice.js
import { createSlice } from '@reduxjs/toolkit';
import { productsApi } from '../../services/api';

const productsSlice = createSlice({
	name: 'products',
	initialState: { list: [], status: 'idle', error: null },
	reducers: {},
	extraReducers: (builder) => {
		builder.addMatcher(
			productsApi.endpoints.getProducts.matchFulfilled,
			(state, action) => {
				state.list = action.payload;
			}
		);
	},
});

export default productsSlice.reducer;

// Sample Component Utilizing All API Slices and Actions
import { useGetProductsQuery } from '../services/productsService';
import {
	useGetCartQuery,
	useAddItemToCartMutation,
} from '../services/cartService';
import { login } from '../features/auth/authActions';
import { selectAuthUser } from '../features/auth/authSelectors';

const Component = () => {
	const dispatch = useDispatch();
	const { data: products, error: productError } = useGetProductsQuery();
	const { data: cart, error: cartError } = useGetCartQuery(1);
	const [addItemToCart] = useAddItemToCartMutation();
	const user = useSelector(selectAuthUser);

	const handleLogin = (credentials) => {
		dispatch(login(credentials));
	};

	const handleAddToCart = (productId) => {
		addItemToCart({ id: productId });
	};

	return (
		<div>
			<button
				onClick={() =>
					handleLogin({ username: 'user', password: 'pass' })
				}
			>
				Login
			</button>
			<div>
				{user ? `Logged in as ${user.username}` : 'Not logged in'}
			</div>
			<div>
				<h2>Products:</h2>
				{productError
					? 'Error loading products'
					: products?.map((p) => <div key={p.id}>{p.name}</div>)}
			</div>
			<div>
				<h2>Cart:</h2>
				{cartError
					? 'Error loading cart'
					: cart?.items.map((item) => (
							<div key={item.id}>
								{item.name}{' '}
								<button
									onClick={() => handleAddToCart(item.id)}
								>
									Add to Cart
								</button>
							</div>
					  ))}
			</div>
		</div>
	);
};
```

```jsx
// Sample Component with asynchronous handlers
// Since createAsyncThunk returns a Promise, marking these functions as async and using await allows waiting for the action to complete
import { useAppDispatch, useAppSelector } from './hooks';
import { addItemToCart, removeItemFromCart, refetchCart } from './cartSlice';

const Cart = () => {
	const dispatch = useAppDispatch();
	const { items, loading, error } = useAppSelector((state) => state.cart);

	// Both handleAddItem and handleRemoveItem involve asynchronous dispatch actions (addItemToCart and removeItemFromCart),
	// which are defined as createAsyncThunk
	const handleAddItem = async (item) => {
		await dispatch(addItemToCart(item));
	};

	const handleRemoveItem = async (id) => {
		await dispatch(removeItemFromCart(id));
	};

	// handleRefetch directly dispatches refetchCart, which is an asynchronous action, but it doesn’t need to await the result.
	// Since the action doesn’t return a data payload (its return type is void), no further operations depend on waiting for a response
	const handleRefetch = (id) => {
		dispatch(refetchCart(id));
	};

	return (
		<div>
			<h1>Cart</h1>
			{loading && <p>Loading...</p>}
			{error && <p>Error: {error}</p>}
			<ul>
				{items.map((item) => (
					<li key={item.id}>
						{item.title} - ${item.price} x {item.quantity}
						<button onClick={() => handleRemoveItem(item.id)}>
							Remove
						</button>
					</li>
				))}
			</ul>
			<button
				onClick={() =>
					handleAddItem({ title: 'New Item', price: 10, quantity: 1 })
				}
			>
				Add Item
			</button>
			<button onClick={() => handleRefetch(1)}>Refetch Cart</button>
		</div>
	);
};
```

### Types for RTK Query & Thunk

```tsx
type CartItem = {
	id: number;
	title: string;
	price: number;
	quantity: number;
};

type GetCartArgs = number;
type AddItemArgs = Omit<CartItem, 'id'>; // Omit - use to exclude property in the type
type RemoveItemArgs = number;

export const cartApi = createApi({
	reducerPath: 'cartApi',
	baseQuery: fetchBaseQuery({ baseUrl: 'https://fakestoreapi.com' }),
	endpoints: (builder) => ({
		// CartItem[]: Specifies that the query returns an array of CartItem objects
		// GetCartArgs: This is the type for the argument required to make the request
		getCart: builder.query<CartItem[], GetCartArgs>({
			query: (id) => `/cart/${id}`,
		}),

		// CartItem: Defines the expected response shape as a single CartItem
		// AddItemArgs: Specifies the input type for the mutation.
		// Here, AddItemArgs would likely be a partial type for CartItem without id,  server usually generates an ID for new items
		addItemToCart: builder.mutation<CartItem, AddItemArgs>({
			query: (item) => ({
				url: `/cart`,
				method: 'POST',
				body: item,
			}),
		}),

		// number: This indicates that the server response will return the id of the item removed
		// RemoveItemArgs: This is the type for the argument required to make the request
		removeItemFromCart: builder.mutation<number, RemoveItemArgs>({
			query: (id) => ({
				url: `/cart/${id}`,
				method: 'DELETE',
			}),
		}),
	}),
});
```

```jsx
// Thunk Return Types
type RefetchCartReturnType = void;
type AddItemReturnType = CartItem;
type RemoveItemReturnType = number;

interface CartState {
	items: CartItem[];
	loading: boolean;
	error: string | null;
}
```

```jsx
// <ReturnValueType, ArgumentType>
// RefetchCartReturnType: Typically defined as void, meaning the action does not have a return value directly
// GetCartArgs: Represents the ID of the cart being refetched, required as an argument
export const refetchCart = createAsyncThunk<RefetchCartReturnType, GetCartArgs>(
	'cart/refetchCart',
	async (id, { dispatch }) => {
		await dispatch(
			cartApi.endpoints.getCart.initiate(id, { forceRefetch: true })
		);
	}
);

// AddItemReturnType: Defines the expected return type from this action. Here, AddItemReturnType would be of type CartItem
// AddItemArgs: Specifies the type for the argument (usually partial data for a CartItem without id)
export const addItemToCart = createAsyncThunk<AddItemReturnType, AddItemArgs>(
	'cart/addItemToCart',
	async (item, { dispatch, rejectWithValue }) => {
		const result = await dispatch(
			cartApi.endpoints.addItemToCart.initiate(item)
		);
		if (result.error) {
			return rejectWithValue(result.error);
		}
		dispatch(refetchCart(result.data!.id));
		return result.data!;
	}
);
```

```jsx
// RemoveItemReturnType: Defines the expected return type as number, representing the ID of the item removed
// RemoveItemArgs: Specifies the type for the input (also number), which is the ID of the item to be removed
export const removeItemFromCart = createAsyncThunk<
	RemoveItemReturnType,
	RemoveItemArgs
>('cart/removeItemFromCart', async (id, { dispatch, rejectWithValue }) => {
	const result = await dispatch(
		cartApi.endpoints.removeItemFromCart.initiate(id)
	);
	if (result.error) {
		return rejectWithValue(result.error);
	}
	dispatch(refetchCart(id));
	return id;
});
```

```jsx
// Using Partial<UserSchema>
// This approach means that any property of UserSchema is optional in the addUser mutation input
// Use if you want flexibility, where not all fields need to be present
addUser: builder.mutation < UserSchema, Partial < UserSchema >> {};

// Using Omit<UserSchema, 'id'>
// This approach indicates that the input to addUser requires all the fields in UserSchema, except for the id field
// Use if you need all other fields except id and want the server or backend to handle the id generation
addUser: builder.mutation < UserSchema, Omit < UserSchema, 'id' >> {};
```

### Snippets

```jsx
// using axios in baseQuery
// set base URLs, add auth tokens, and manage error responses
import axios from 'axios';
import { createApi, fetchBaseQuery } from '@reduxjs/toolkit/query/react';

const axiosBaseQuery =
	({ baseUrl }) =>
	async ({ url, method, data, params }) => {
		try {
			const result = await axios({
				url: baseUrl + url,
				method,
				data,
				params,
				headers: {
					Authorization: `Bearer ${localStorage.getItem('token')}`,
				},
			});
			return { data: result.data };
		} catch (axiosError) {
			let err = axiosError;
			return {
				error: {
					status: err.response?.status,
					data: err.response?.data,
				},
			};
		}
	};

export const myApi = createApi({
	reducerPath: 'myApi',
	baseQuery: axiosBaseQuery({ baseUrl: 'https://api.example.com' }),
	endpoints: (builder) => ({
		getExampleData: builder.query({ query: () => ({ url: '/example' }) }),
	}),
});
```

```jsx
// Dynamically Register Reducers and Middleware
// src/app/store.js - Create the store and add dynamic reducer handling
import { configureStore } from '@reduxjs/toolkit';

const store = configureStore({
	reducer: {}, // Start with an empty root reducer
	middleware: (getDefaultMiddleware) => getDefaultMiddleware(),
});

// Utility to dynamically add reducers
store.asyncReducers = {};

export const injectReducer = (key, reducer) => {
	if (!store.asyncReducers[key]) {
		store.asyncReducers[key] = reducer;
		store.replaceReducer(combineReducers(store.asyncReducers));
	}
};
```

```jsx
// Utility to dynamically add middleware
// appliedMiddleware is a Set object, which is a data structure that stores unique values
const appliedMiddleware = new Set();

export const injectMiddleware = (middleware) => {
	// This condition checks if the middleware hasn’t already been added to appliedMiddleware
	if (!appliedMiddleware.has(middleware)) {
		// updates the store.middleware array by spreading the existing middleware and appending the new middleware item
		store.middleware = [...store.middleware, middleware];

		// replaces the root reducer with a new one, including any updates made to store.asyncReducers
		store.replaceReducer(combineReducers(store.asyncReducers));

		// adds the middleware to the appliedMiddleware set
		// keeps track of the middleware already added so they are not re-added, preventing duplication
		appliedMiddleware.add(middleware);
	}
};

export default store;
```

```jsx
// Feature-specific Reducer and Middleware Registration
// Each feature file or page can import and register reducers and middleware dynamically when needed
// src/features/auth/index.js
import { injectReducer, injectMiddleware } from '../../app/store';
import authReducer, { authApi } from './authSlice';

injectReducer('auth', authReducer);
injectMiddleware(authApi.middleware); // Dynamically add auth middleware only when feature is used

// Usage Example in a Component
import { injectReducer, injectMiddleware } from '../../app/store';
import authReducer, { authApi } from './authSlice';
import AuthComponent from './AuthComponent';

const AuthPage = () => {
	useEffect(() => {
		injectReducer('auth', authReducer);
		injectMiddleware(authApi.middleware);
	}, []);

	return <AuthComponent />;
};

export default AuthPage;
```

```jsx
// avoid caching data altogether or always fetch fresh data from the server
// 1. Disabling Cache Completely
const api = createApi({
	reducerPath: 'api',
	baseQuery: fetchBaseQuery({ baseUrl: '/api' }),
	endpoints: (builder) => ({
		getProduct: builder.query({
			query: (id) => `product/${id}`,
			// Removes data from cache immediately after the query is no longer used
			keepUnusedDataFor: 0,
		}),
	}),
});
```

```jsx
// 2. Always Fetching Fresh Data
// bypass the cache and always make a new request to the server
const { data } = api.useGetProductQuery(id, {
	// Setting this to true will trigger a new fetch every time the component mounts or when the query argument changes
	refetchOnMountOrArgChange: true,

	// Useful for re-fetching data when the user reconnects to the network, ensuring you have fresh data after a disconnection
	refetchOnFocus: true,

	// Setting this to true will make RTK Query fetch fresh data whenever the browser window regains focus
	refetchOnReconnect: true,
});
```
